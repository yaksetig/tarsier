// Example: Reliable broadcast with process-selective network semantics.
// Demonstrates the process_selective network mode, where every process
// has a concrete identity and channels are fully per-process.
// This achieves instance-exact semantics with the faithful protocol model.
//
// Note: process_selective requires identity declarations with process(var)
// scope and a bounded pid variable. Results are exact but not parameterized.
protocol ReliableBroadcastProcessSelective {
    params n, t, f;
    resilience: n > 3*t;

    adversary {
        model: byzantine;
        bound: f;
        auth: signed;
        network: process_selective;
        delivery: per_recipient;
        faults: per_recipient;
        equivocation: none;
    }

    identity Process: process(pid) key process_key;

    message Init;
    message Echo;
    message Ready;

    role Process {
        var pid: nat in 0..1;
        var accepted: bool = false;
        var decided: bool = false;
        var decision: bool = false;

        init waiting;

        phase waiting {
            when received >= 1 Init => {
                accepted = true;
                send Echo;
                goto phase echoed;
            }
        }

        phase echoed {
            when received distinct >= 2*t+1 Echo => {
                send Ready;
                goto phase readied;
            }
        }

        phase readied {
            when received distinct >= 2*t+1 Ready => {
                decision = true;
                decided = true;
                decide true;
                goto phase done;
            }
        }

        phase done {}
    }

    property agreement: agreement {
        forall p: Process. forall q: Process.
            (p.decided == true && q.decided == true) ==> (p.decision == q.decision)
    }
}
