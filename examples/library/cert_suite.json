{
  "schema_version": 2,
  "enforce_library_coverage": true,
  "enforce_corpus_breadth": true,
  "enforce_model_hash_consistency": true,
  "enforce_known_bug_sentinels": true,
  "required_known_bug_families": [
    "pbft",
    "hotstuff",
    "tendermint",
    "reliable-broadcast",
    "viewstamped-replication",
    "zab"
  ],
  "required_variant_groups": [
    "pbft_simple_safe",
    "hotstuff_safe_kernel",
    "reliable_broadcast_safe",
    "vr_safe",
    "zab_safe"
  ],
  "library_dir": ".",
  "entries": [
    {
      "file": "algorand_vote_cert.trs",
      "family": "algorand",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Known modeling bug benchmark: Algorand-style vote certification with intentionally weak certificate threshold allows conflicting vote certificates to coexist, exposing a safety counterexample.",
      "model_sha256": "0c51058ae19499e4e1b13694a271181f5b979442febe34dedccc22aa29dca0de"
    },
    {
      "file": "casper_ffg_like.trs",
      "family": "casper",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Casper FFG-style finality gadget with conflicting justification paths; the supermajority link rule is intentionally weakened so that two incompatible checkpoints can both be justified, violating agreement.",
      "model_sha256": "3ce0e069021612269bcbda4981b1c9440305c139b092b69ae4d04108ec163729"
    },
    {
      "file": "diembft_epoch.trs",
      "family": "diembft",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "DiemBFT epoch-change kernel modeling threshold-signature LedgerQC formation under partial synchrony with n>3t Byzantine resilience. Agreement holds because the 2t+1 distinct vote threshold prevents conflicting QCs from forming in the same epoch.",
      "model_sha256": "f0efdee716b419102d1bf5ddbc6a5b6d0d52482769e33fd6bd14b3dadb12281b"
    },
    {
      "file": "dls_partial_sync.trs",
      "family": "dls",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: DLS-style partial-synchrony protocol where the transition from asynchronous to synchronous mode admits a split-decision trace; processes can commit to different values before GST arrives.",
      "model_sha256": "b220ccf7c244eeb8dd8371458de7aaff5fed6717f58d8b42759ef5fb4d6270a0"
    },
    {
      "file": "grandpa_finality.trs",
      "family": "grandpa",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: GRANDPA-style finality voting rule intentionally weakened; the prevote/precommit quorum interaction allows two conflicting blocks to both reach finality, violating the accountable safety property.",
      "model_sha256": "790b385c714efa73c68963825d6ecf172e641203006963d94a64cf1715a0ec38"
    },
    {
      "file": "hbbft_acs_like.trs",
      "family": "hbbft",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "HoneyBadgerBFT-style asynchronous common subset kernel with two-stage RBC+BA protocol under omission faults (n=3f+1). Agreement holds because each stage requires n-f messages ensuring at least one honest quorum overlap.",
      "model_sha256": "78372597113dc92a404b9b3f7c2f6d69f82693958f31f741003302d458c39d6d"
    },
    {
      "file": "hotstuff_chained.trs",
      "family": "hotstuff",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: chained HotStuff model with intentionally weakened commit rule; the three-chain safety argument fails because the guard on the third QC does not enforce view monotonicity, admitting conflicting commit paths.",
      "model_sha256": "982a3dbfc09d332bf1693e76c79deae8fa673a990097f18a8f49fbe70d5560d1"
    },
    {
      "file": "hotstuff_crypto_qc_bug_faithful.trs",
      "family": "hotstuff",
      "class": "known_bug",
      "verify": "unsafe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive bug seed: HighQC is modeled without conflict admissibility under full equivocation. A Byzantine signer can create conflicting certificate variants (value=true/false), leading to split decisions and an agreement violation.",
      "model_sha256": "0c7c8ee392f0c0f6acb7b23a6f53380a6ee0e3dcf3fdf01df1f98bb7e242797c"
    },
    {
      "file": "hotstuff_crypto_qc_safe_faithful.trs",
      "family": "hotstuff",
      "class": "expected_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive faithful HotStuff kernel: HighQC uses signer-scoped certificate formation with `conflicts exclusive` and no equivocation, preventing conflicting certificates and preserving agreement.",
      "model_sha256": "cb275bb7ba341e40a3bc2d279734e79fba6bf2c6659235ad8488ae64885b925a"
    },
    {
      "file": "hotstuff_simple_safe_faithful.trs",
      "family": "hotstuff",
      "class": "expected_safe",
      "variant": "faithful",
      "variant_group": "hotstuff_safe_kernel",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Faithful-network HotStuff-style safety kernel with identity-selective delivery, signed authentication, and per-recipient fault injection. Uses distinct sender counting in receive guards to model realistic quorum certificate formation.",
      "model_sha256": "bf47fb1cf9086d123e64c3c6f5989a142dae90cb90f80b94952413aef9b4af16"
    },
    {
      "file": "jolteon_fast_hotstuff.trs",
      "family": "hotstuff",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Jolteon/Fast-HotStuff-style protocol kernel under partial synchrony with n>3t Byzantine resilience. Models HighQC certificate formation from 2t+1 NewView messages; agreement holds via quorum intersection of the fast-path certificate threshold.",
      "model_sha256": "3fa44c6e112990fd9dfc79eba987c0e0a80c698f605fc090da2a7d0e467f3483",
      "variant": "minimal",
      "variant_group": "hotstuff_safe_kernel"
    },
    {
      "file": "multi_paxos_round.trs",
      "family": "paxos",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Multi-Paxos single-round kernel with crash fault model (n>3t). Models slot-based agreement via 2t+1 Learn-message quorum; safety holds because any two quorums of size 2t+1 overlap in at least one honest process.",
      "model_sha256": "a6e965bde7a80a52907cc330bbc6ec6b57f1e2a4df294d1ea10d439a0960819d"
    },
    {
      "file": "narwhal_bullshark_vote.trs",
      "family": "narwhal-bullshark",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Narwhal/Bullshark DAG-based certificate rule intentionally allows conflicting delivery decisions; the certificate formation threshold is set below the quorum intersection bound required for agreement.",
      "model_sha256": "47f4cd524ffa0828e63e8a4143b346bb030665ff67901ede3edbe209d0c45a55"
    },
    {
      "file": "paxos_basic.trs",
      "family": "paxos",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Classic single-decree Paxos kernel with crash fault model (n>3t). Models the core promise-accept-learn pattern via 2t+1 Learn-message quorum; agreement follows from the majority quorum intersection property.",
      "model_sha256": "e8f42807e7d3fba96a613eb25af242a2197e4e24f5c2743452bacba2b402e630"
    },
    {
      "file": "pbft_core.trs",
      "family": "pbft",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: core PBFT pre-prepare/prepare/commit flow with intentionally under-constrained quorum threshold; the prepare certificate does not require 2f+1 distinct senders, allowing Byzantine nodes to forge a conflicting certificate.",
      "model_sha256": "c436961d0bec34daebbb921e89ccd65d87d9d90861a0a3d5bac751c1ab75ec24"
    },
    {
      "file": "pbft_crypto_qc_bug_faithful.trs",
      "family": "pbft",
      "class": "known_bug",
      "verify": "unsafe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive bug seed for PBFT-style prepare certificates: with full equivocation and no certificate conflict policy, Byzantine traffic can produce conflicting PrepareQC variants and violate agreement.",
      "model_sha256": "92398198155909e2c73a0b229737954fbd83652f07e82af89c08c0f2caafa8d8"
    },
    {
      "file": "pbft_crypto_qc_safe_faithful.trs",
      "family": "pbft",
      "class": "expected_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive faithful PBFT kernel: PrepareQC formation is signer-scoped and `conflicts exclusive` under no-equivocation assumptions, preventing contradictory certificates and preserving agreement.",
      "model_sha256": "95230dae6b6c272ac269ed6a17d5055f4c511f76c795de847edbd151d7e2bf02"
    },
    {
      "file": "pbft_liveness_buggy_ci.trs",
      "family": "pbft",
      "class": "known_bug",
      "verify": "safe",
      "liveness": "not_live",
      "fair_liveness": "fair_cycle_found",
      "prove_fair": "fair_cycle_found",
      "fairness": "weak",
      "k": 8,
      "cegar_iters": 0,
      "notes": "PBFT-shaped liveness regression sentinel for unbounded proving: no commit source is modeled, so fair non-terminating cycles remain reachable under weak fairness. This entry anchors expected non-live outcomes for bounded and unbounded liveness checks.",
      "model_sha256": "6f77a73c46cc25676d75e4fbbb66fb39d17cca4cdd70bb895e46b34811ce89a5"
    },
    {
      "file": "pbft_liveness_safe_ci.trs",
      "family": "pbft",
      "class": "expected_safe",
      "verify": "safe",
      "liveness": "live",
      "fair_liveness": "no_fair_cycle_up_to",
      "prove_fair": "live_proved",
      "fairness": "weak",
      "k": 8,
      "cegar_iters": 0,
      "notes": "PBFT-shaped nontrivial CI anchor with partial-synchrony/adversary/message structure and a deterministic live target. Used for stable unbounded fair-liveness certificate generation and replay gates.",
      "model_sha256": "23974d62dbebdb502e1f3f3ef015988c633489ec5a80d8826fc557824f204d05"
    },
    {
      "file": "pbft_simple_safe.trs",
      "family": "pbft",
      "class": "expected_safe",
      "verify": "safe",
      "prove": "safe",
      "k": 8,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Minimal PBFT safety kernel without view-change: models the pre-prepare/prepare/commit three-phase pattern with correct 2t+1 quorum thresholds under n>3t Byzantine resilience. Proved safe by k-induction at k=8.",
      "model_sha256": "d97fa448f441bc7d33c130c3b6821627ffb054d974240dc0594500ec0b274e66",
      "variant": "minimal",
      "variant_group": "pbft_simple_safe"
    },
    {
      "file": "pbft_simple_safe_faithful.trs",
      "family": "pbft",
      "class": "expected_safe",
      "variant": "faithful",
      "variant_group": "pbft_simple_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Faithful-network PBFT safety kernel with identity-selective delivery, signed channels, and per-recipient fault injection. Mirrors the minimal PBFT kernel but with distinct sender counting and explicit equivocation=none enforcement.",
      "model_sha256": "e7f601f71bdd995aecccfd6f13be67e6ca1f0e9ad3a954b91a6019e4fddc8b33"
    },
    {
      "file": "pbft_view_change.trs",
      "family": "pbft",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: PBFT with view-change extension where the carry-over of prepared certificates across views is intentionally incomplete; a new primary can propose a value conflicting with a previously prepared one.",
      "model_sha256": "4da134804d0d7eb256867c61e6e431a04f312c8e09a3e23d64f6e84c1205d900"
    },
    {
      "file": "qbft_round_change.trs",
      "family": "qbft",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "QBFT round-change kernel modeling the Istanbul BFT variant with n=3f+1 Byzantine resilience. The preprepare-prepare-roundchange flow ensures agreement because the 2f+1 distinct Prepare quorum prevents conflicting pre-prepared values across rounds.",
      "model_sha256": "b521fc954578af9b793f697c98421f04580e6d6c79a550187f596361c3d1bece"
    },
    {
      "file": "raft_election_safety.trs",
      "family": "raft",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Raft election safety kernel under omission faults with partial synchrony (n>3t). Models single-term leader election via 2t+1 Vote quorum; agreement holds because each replica votes at most once per term, ensuring at most one leader per term.",
      "model_sha256": "056f2cd875a2a63750f704923f779aa6f0854085e24c39b8ac8fb5cdc26293fb"
    },
    {
      "file": "reliable_broadcast_buggy.trs",
      "family": "reliable-broadcast",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 8,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Bracha reliable-broadcast variant with intentionally weakened quorum thresholds in the Echo/Ready phases; permits two honest processes to accept conflicting values because the quorum intersection is insufficient.",
      "model_sha256": "265e1b137012f21a9bc1554d08c48ba1bcedb18718b6108af2ae48564022f1e5"
    },
    {
      "file": "reliable_broadcast_safe.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "verify": "safe",
      "prove": "safe",
      "k": 8,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bracha reliable-broadcast safety kernel with correct n>3t threshold: Init/Echo/Ready three-phase pattern where 2t+1 Echo threshold and 2t+1 Ready threshold ensure quorum intersection guarantees agreement. Proved safe by k-induction at k=8.",
      "model_sha256": "7e2abcdb85e14aef2b98424e588f7949339d2ac0e1873ff7177cc08c96926a16",
      "variant": "minimal",
      "variant_group": "reliable_broadcast_safe"
    },
    {
      "file": "reliable_broadcast_safe_faithful.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "variant": "faithful",
      "variant_group": "reliable_broadcast_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Faithful-network Bracha reliable-broadcast with identity-selective delivery, signed authentication, and distinct sender counting. Mirrors the minimal kernel but models per-recipient fault injection and explicit no-equivocation enforcement.",
      "model_sha256": "504c0bcecac6687dbc9a900d668a16ec5b4881ca979aa08e5756d14b6714840f"
    },
    {
      "file": "sbft_committee.trs",
      "family": "sbft",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: SBFT-style committee-based protocol with intentionally weak committee selection and commit conditions; the fast-path commit threshold allows a Byzantine-dominated committee to finalize conflicting values.",
      "model_sha256": "66fcac91ebdae84bfedf5474137d6fe1635ec40f9ca98606a28c51239585ae9d"
    },
    {
      "file": "streamlet.trs",
      "family": "streamlet",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Streamlet notarization rule intentionally allows conflicting finalized outcomes; the three-consecutive-notarized-block finality rule is weakened so that two conflicting chains can both satisfy the finalization criterion.",
      "model_sha256": "d0d3b80db9fd52b2122bdd80ba16d5d65252c7ba4c87e8338cfd8c0356ec4a6a"
    },
    {
      "file": "temporal_liveness_counterexample.trs",
      "family": "temporal",
      "class": "known_bug",
      "liveness": "not_live",
      "fair_liveness": "no_fair_cycle_up_to",
      "depth": 8,
      "notes": "Temporal leads-to violation benchmark for bounded liveness: models a protocol where the liveness property (eventually all processes decide) can be violated by a stalling execution, but no fair cycle exists up to the exploration depth.",
      "model_sha256": "f719838372306a0882f4e865f5434d9351c3d815543ef71863ffdcb7e854949e"
    },
    {
      "file": "tendermint_locking.trs",
      "family": "tendermint",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Tendermint locking/precommit conditions intentionally relaxed; the lock-change rule does not properly enforce that a process must see a polka for a different value before unlocking, admitting conflicting precommits.",
      "model_sha256": "e9c5b4b774df31ca39f0c5447063ff8294112b7576397d4245d2805676b570a3"
    },
    {
      "file": "tendermint_crypto_qc_bug_faithful.trs",
      "family": "tendermint",
      "class": "known_bug",
      "verify": "unsafe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive bug seed for Tendermint polka certificates: full equivocation plus missing conflict admissibility allows conflicting Polka variants and split decisions.",
      "model_sha256": "7a5e21ce36041a4ce9059d04a2ee5dbf9c7949520081fa936a957da18250f747"
    },
    {
      "file": "tendermint_crypto_qc_safe_faithful.trs",
      "family": "tendermint",
      "class": "expected_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Crypto-object decisive faithful Tendermint kernel: signer-scoped Polka formation with `conflicts exclusive` under no-equivocation assumptions eliminates conflicting certificates and preserves agreement.",
      "model_sha256": "2f820e65a040c82dc66cbb70d96ab4a972d589b81795d77b0b1bbfd153f6cdbf"
    },
    {
      "file": "trivial_live.trs",
      "family": "sanity",
      "class": "expected_safe",
      "verify": "safe",
      "prove": "safe",
      "liveness": "live",
      "fair_liveness": "no_fair_cycle_up_to",
      "prove_fair": "live_proved",
      "k": 8,
      "proof_engine": "kinduction",
      "fairness": "weak",
      "cegar_iters": 0,
      "notes": "Minimal sanity benchmark that exercises all five check modes (verify, prove, liveness, fair_liveness, prove_fair). Trivially satisfies all properties to ensure the engine pipeline is end-to-end functional.",
      "model_sha256": "2ba4400bec83355db41fa328c00919987a94de5ac1b91c1031612628aebd8785"
    },
    {
      "file": "tusk_dag_cert.trs",
      "family": "tusk",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Tusk DAG-based certificate protocol kernel under Byzantine faults (n>3t) with signed authentication. Models certificate formation from 2t+1 distinct Vote messages; agreement follows from the quorum intersection property of the DAG layer.",
      "model_sha256": "6718192846c673b00472dc2eaf303a701cdb586fb410dcc9b46a41ccf30433e3"
    },
    {
      "file": "viewstamped_replication.trs",
      "family": "viewstamped-replication",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Viewstamped Replication safety kernel with crash fault model (n=2f+1). Three-phase StartView/Prepare/Commit flow where each stage requires n-f messages; agreement holds because any two quorums of n-f crash-tolerant replicas overlap.",
      "model_sha256": "3d3f1f3017365c4601b2c933ac72fd0ec1350aea87f5125d53c8805f76062028",
      "variant": "minimal",
      "variant_group": "vr_safe"
    },
    {
      "file": "viewstamped_replication_buggy.trs",
      "family": "viewstamped-replication",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Viewstamped Replication variant with zero-threshold transitions that bypass the quorum guards; processes can skip directly to the commit phase without collecting sufficient StartView/Prepare acknowledgments.",
      "model_sha256": "36d191f6c6340375f1e66938ebc3e83b6f5927bf589c328be18b0e8180c2fe8e"
    },
    {
      "file": "viewstamped_replication_faithful.trs",
      "family": "viewstamped-replication",
      "class": "expected_safe",
      "variant": "faithful",
      "variant_group": "vr_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Faithful-network Viewstamped Replication with identity-selective delivery, signed authentication, distinct sender counting, and per-recipient fault injection. Mirrors the minimal VR kernel under a more detailed network model.",
      "model_sha256": "939e5d7d3bf56c620a1700a3c7c6b127b2dfcc11e0070a16f5093c9e5b66bb12"
    },
    {
      "file": "zab_atomic_broadcast.trs",
      "family": "zab",
      "class": "expected_safe",
      "verify": "safe",
      "notes": "Zab-style atomic broadcast kernel under omission faults with partial synchrony (n=2f+1). Three-phase Proposal/Ack/Commit flow where each stage requires n-f messages; agreement holds because omission-tolerant quorums overlap.",
      "model_sha256": "dfe9b032f23fd18c33b994a30c5e7ed49e4bc85805c1c0a26ee9a8857611cc2e",
      "variant": "minimal",
      "variant_group": "zab_safe"
    },
    {
      "file": "zab_atomic_broadcast_buggy.trs",
      "family": "zab",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Zab-style atomic broadcast with zero-threshold transitions that bypass quorum guards; replicas can advance through Proposal/Ack/Commit phases without sufficient acknowledgments, admitting conflicting commits.",
      "model_sha256": "ba88b4fa1cbdb28b1c2da15910cd10a314901c22a509988deecd5a0c6874faee"
    },
    {
      "file": "zab_atomic_broadcast_faithful.trs",
      "family": "zab",
      "class": "expected_safe",
      "variant": "faithful",
      "variant_group": "zab_safe",
      "verify": "safe",
      "depth": 4,
      "cegar_iters": 0,
      "notes": "Faithful-network Zab atomic broadcast with identity-selective delivery, signed authentication, distinct sender counting, and per-recipient omission fault injection. Mirrors the minimal Zab kernel under a more detailed network model.",
      "model_sha256": "803370ae57386bc296fafb0b9ae2a21f2eb0ca50d19e002264e6ed1e8896a87e"
    },
    {
      "file": "zyzzyva_fastpath.trs",
      "family": "zyzzyva",
      "class": "known_bug",
      "verify": "unsafe",
      "prove": "unsafe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Bug seed: Zyzzyva fast-path certificate threshold intentionally set below 3f+1, allowing a Byzantine coalition to forge a conflicting fast-path certificate and violate agreement.",
      "model_sha256": "afa67e3c171238b7f3779ede78c17dfcba249b00f2fc31f86f17de4dbdf741ee"
    },
    {
      "file": "reliable_broadcast_safe_live.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "verify": "safe",
      "prove": "safe",
      "k": 10,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Reliable Broadcast with liveness property (termination). Safety (agreement) holds; bounded fair-liveness may report spurious cycle due to counter abstraction over-approximation.",
      "model_sha256": "91513a2d7b655462bc3f3ea75d0b60e2d526c587c0ad29c330104971f84ad26e"
    },
    {
      "file": "reliable_broadcast_live_buggy.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "verify": "safe",
      "k": 10,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Reliable Broadcast with liveness bug: self-loop in echoed phase allows non-termination under weak fairness. Safety (agreement) still holds since the bug is a liveness bug, not a safety bug.",
      "model_sha256": "3cd7ced6b09d384de954578cff6ce7146556a432c22319e0b34dec18630bd54a"
    },
    {
      "file": "voting_enum_phases.trs",
      "family": "voting",
      "class": "expected_safe",
      "verify": "safe",
      "k": 6,
      "proof_engine": "kinduction",
      "cegar_iters": 0,
      "notes": "Example demonstrating enum type declarations in the DSL. Simple majority-vote protocol with enum Vote { yes, no } phases.",
      "model_sha256": "58982b4aee598b4e8a8953673e6b3d00a49312b9424566ffacf3e9792e643af8"
    },
    {
      "file": "reliable_broadcast_cohort_selective.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "verify": "safe",
      "depth": 2,
      "cegar_iters": 0,
      "notes": "Reliable Broadcast with cohort-selective network semantics. Demonstrates per-cohort Byzantine delivery channels with higher-fidelity counter abstraction.",
      "model_sha256": "838f230c56df47c771f26e7c2d3249c53cb324e5edb5e9b87a73ea53037de85e"
    },
    {
      "file": "reliable_broadcast_process_selective.trs",
      "family": "reliable-broadcast",
      "class": "expected_safe",
      "verify": "safe",
      "depth": 2,
      "cegar_iters": 0,
      "notes": "Reliable Broadcast with process-selective network semantics. Demonstrates concrete process identities with per-process channels for instance-exact verification.",
      "model_sha256": "d208f88fbfd06d537e6a7fcf5e4775c99d2a1515a9bd281e4b47dfe22d7fd8fa"
    }
  ]
}
